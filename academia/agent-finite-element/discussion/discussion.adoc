= Coursework 2 Discussion
:nofooter:
:stem:

For each question, results are discussed first, and then some coding aspects
are discussed. Some of the modules from Coursework 1 are reused here. Main
scripts for Questions 1 and 2 are `question1.py` and `question2.py`,
respectively. Modules used in either question are in `src/Common`. Modules that
are more specific to the question at hand are in `src/Special`. Test modules
are in `src/tests`. Documentation (generated by Sphinx) is
link:../apidocs/[here].

== Question 1

=== Results

A flock of four boids is trained to determine an appropriate cohesion
parameter, stem:[C], by minimizing the variance in the average flock widths
during time evolution from stem:[t = 0] to stem:[t = 5] in equal steps of
stem:[Delta t = 0.1] as stated in the question. From this, stem:[C] is
determined to be approximately stem:[0.750].

Then, a flock of 50 boids that is randomly distributed in position with varying
velocities as stated in the question is evolved from stem:[t = 0] to stem:[t =
10] in equal steps of stem:[Delta t = 0.05]. For reproducibility, the seed used
is stem:[2].

According to the plot and animation, the flock appears to be initially
together, but as time progresses, the flock separates into two groups flying in
different directions. The average flock width increases over time, since the
flock splits into two. The average velocity of the flock does not vary much
over time.

An MP4 file (also embedded below) and two frames as PNG are in `img/question1`.

video::media/flock-evolution.mp4[]

=== Coding Aspects

In addition to several classes dedicated to flocks and boids, a simple
event-based system is used to evolve the flock. Every boid is a member of a
flock. During instance construction, the boid registers its event handler in
order to receive notifications from the flock. Hence, the flock is able to
notify every boid of the time progression. Upon receiving the notification,
each boid determines its new velocity angle based on its neighboring boids in
preparation for updating its trajectory. Finally, the boids update their
trajectories for the timestep.

This obviates copying objects, while maintaining the relationships among the
boids within the flock. Encapsulation of the relationships among the boids is
important, since it allows the determination of neighboring boids and new
trajectories to be performed automatically while enforcing information hiding.

== Question 2

=== Results

As the Dirichlet boundary conditions dictate, the right edge (stem:[Gamma_(T)],
where stem:[x = 4]) of Big G has the prescribed temperature of stem:[bar T =
0]. As stated in the question, the normal derivative at the remainder of the
boundary, stem:[Gamma_(q)], is stem:[0]:

[stem]
++++
grad T * bb n = 0 " on " Gamma_(q)
++++

Based on the 2D and 3D plots, the temperature is highest at the bottom-left
corner of Big G. Furthermore, the temperature distribution indicates that the
temperature increases as one moves toward that corner. The leg lengths of the
triangle used are stem:[1/2] and stem:[1/16], with the latter resulting in a
higher resolution of the solution. Regardless of which leg length is used, the
description of the temperature distribution holds.

Plots of the temperature distribution using the two leg lengths are in
`img/question2`.

=== Coding Aspects

The global indices of nodes provided in the question are reused during the
construction of the `Mesh` object (in the specialized module, `BigGMesh`).

The stiffness matrix presents the greatest difficulty, since it is difficult to
calculate the matrix terms in a manner that is both direct and natural. The
latter is opted for at the cost of indirectness in regards to coding. In
calculating the stiffness matrix terms, local-to-matrix index mapping of nodes,
coordinate transformation, Jacobian, and others are needed. To manage such
complexities, OOP is chosen as the main paradigm once again.

To determine the local index of a node in an element, polymorphism is employed.
By not caring whether the right triangle is lower or upper on the client side
of the code, the underlying object that represents the element takes care of
returning the correct node for a given local index. This is an object-oriented
manifestation of the IEN.

Although the shape functions and their derivatives are simple enough, they are
still abstracted using abstract data types, specifically `SympyFn` and
`VectorFn`. Instances of both classes are callable, which makes coding
significantly more natural. This also allows for the utilization of functions
that were designed for general-purpose use (e.g., taking the gradient of a
function represented by a `SympyFn` object and getting the Jacobian of a
vector-valued function represented by a `VectorFn` object). Coordinate
transformation becomes simple and less error-prone.

All of this results in the main script being relatively straightforward to
code.
