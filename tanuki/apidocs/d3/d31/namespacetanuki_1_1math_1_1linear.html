<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.6"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Tanuki: tanuki::math::linear Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Tanuki
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.6 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="../../d9/d1a/namespacetanuki.html">tanuki</a></li><li class="navelem"><a class="el" href="../../d7/dd3/namespacetanuki_1_1math.html">math</a></li><li class="navelem"><a class="el" href="../../d3/d31/namespacetanuki_1_1math_1_1linear.html">linear</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">tanuki::math::linear Namespace Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/daf/classtanuki_1_1math_1_1linear_1_1CholeskyDecomposition.html">CholeskyDecomposition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cholesky decomposition of a matrix.  <a href="../../d9/daf/classtanuki_1_1math_1_1linear_1_1CholeskyDecomposition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dc/d23/structtanuki_1_1math_1_1linear_1_1IndexedVectorPair.html">IndexedVectorPair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pair of vectors with their indices.  <a href="../../dc/d23/structtanuki_1_1math_1_1linear_1_1IndexedVectorPair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/dca/structtanuki_1_1math_1_1linear_1_1MatrixIndexPair.html">MatrixIndexPair</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pair of matrix indices, both of which are either rows or columns.  <a href="../../db/dca/structtanuki_1_1math_1_1linear_1_1MatrixIndexPair.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d5a/structtanuki_1_1math_1_1linear_1_1NumberArray.html">NumberArray</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Array of numbers that are either real or complex.  <a href="../../d2/d5a/structtanuki_1_1math_1_1linear_1_1NumberArray.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dab/structtanuki_1_1math_1_1linear_1_1QrDecomposition.html">QrDecomposition</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">QR decomposition of a matrix.  <a href="../../d6/dab/structtanuki_1_1math_1_1linear_1_1QrDecomposition.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d13/structtanuki_1_1math_1_1linear_1_1RotationMatrixSpec.html">RotationMatrixSpec</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specification of a rotation matrix using the cosine and sine of an angle.  <a href="../../dd/d13/structtanuki_1_1math_1_1linear_1_1RotationMatrixSpec.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ac20acd153246fd5892b4d2f7da77023d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac20acd153246fd5892b4d2f7da77023d"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d31/namespacetanuki_1_1math_1_1linear.html#ac20acd153246fd5892b4d2f7da77023d">EigSolver</a> = function&lt; void(Col&lt; real_t &gt; &amp;, Mat&lt; T &gt; &amp;, const Mat&lt; T &gt; &amp;, const Mat&lt; T &gt; &amp;)&gt;</td></tr>
<tr class="memdesc:ac20acd153246fd5892b4d2f7da77023d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of function that solves a generalized eigenvalue equation.  <br /></td></tr>
<tr class="separator:ac20acd153246fd5892b4d2f7da77023d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2bf93f4252e39d78e6d62435f773fdc4"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2bf93f4252e39d78e6d62435f773fdc4"><td class="memTemplItemLeft" align="right" valign="top">Mat&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d31/namespacetanuki_1_1math_1_1linear.html#a2bf93f4252e39d78e6d62435f773fdc4">EquationSystemSolution</a> (MPI_Comm mpi_comm, const Mat&lt; T &gt; &amp;coeffs, const Mat&lt; T &gt; &amp;constants)</td></tr>
<tr class="memdesc:a2bf93f4252e39d78e6d62435f773fdc4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves a system of linear equations, \( \mathbf{A} \mathbf{x} =
\mathbf{b} \).  <br /></td></tr>
<tr class="separator:a2bf93f4252e39d78e6d62435f773fdc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0b643b871d049345e0c2c204b5f56ca"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac0b643b871d049345e0c2c204b5f56ca"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/dab/structtanuki_1_1math_1_1linear_1_1QrDecomposition.html">QrDecomposition</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d31/namespacetanuki_1_1math_1_1linear.html#ac0b643b871d049345e0c2c204b5f56ca">IteratedGramSchmidt</a> (MPI_Comm mpi_comm, const arma::Mat&lt; T &gt; &amp;matrix, real_t reortho_thresh_factor=0.5, size_t max_reorthos=1, real_t zero_norm_abs_thresh=1.0e-5)</td></tr>
<tr class="memdesc:ac0b643b871d049345e0c2c204b5f56ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Numerically stable Gram-Schmidt process with reorthogonalization.  <br /></td></tr>
<tr class="separator:ac0b643b871d049345e0c2c204b5f56ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0050bbd470dbe20f831a88dad4f8a5a1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0050bbd470dbe20f831a88dad4f8a5a1"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d6/dab/structtanuki_1_1math_1_1linear_1_1QrDecomposition.html">QrDecomposition</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d31/namespacetanuki_1_1math_1_1linear.html#a0050bbd470dbe20f831a88dad4f8a5a1">IteratedGramSchmidt</a> (MPI_Comm mpi_comm, const Mat&lt; T &gt; &amp;matrix, real_t reortho_thresh_factor, size_t max_reorthos, real_t zero_norm_abs_thresh)</td></tr>
<tr class="separator:a0050bbd470dbe20f831a88dad4f8a5a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d71c61fce62c7deffa851d4bb540b5"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Tmats&gt; </td></tr>
<tr class="memitem:a88d71c61fce62c7deffa851d4bb540b5"><td class="memTemplItemLeft" align="right" valign="top">Mat&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d31/namespacetanuki_1_1math_1_1linear.html#a88d71c61fce62c7deffa851d4bb540b5">MatrixProduct</a> (MPI_Comm mpi_comm, const Mat&lt; T &gt; &amp;a, const Mat&lt; T &gt; &amp;b, Tmats... mats)</td></tr>
<tr class="memdesc:a88d71c61fce62c7deffa851d4bb540b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multiplication of Armadillo matrices with parallelization across MPI processes.  <br /></td></tr>
<tr class="separator:a88d71c61fce62c7deffa851d4bb540b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1c8f872ee43f871dd43e98a88d66cb4"><td class="memTemplParams" colspan="2">template&lt;typename T , typename ForwardIt , typename std::enable_if&lt; std::is_convertible&lt; typename std::iterator_traits&lt; ForwardIt &gt;::value_type, T &gt;::value, bool &gt;::type  = true&gt; </td></tr>
<tr class="memitem:ae1c8f872ee43f871dd43e98a88d66cb4"><td class="memTemplItemLeft" align="right" valign="top">Mat&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d31/namespacetanuki_1_1math_1_1linear.html#ae1c8f872ee43f871dd43e98a88d66cb4">DuoProduct</a> (MPI_Comm mpi_comm, const Mat&lt; T &gt; &amp;a, ForwardIt b_first)</td></tr>
<tr class="memdesc:ae1c8f872ee43f871dd43e98a88d66cb4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the matrix product, \( \mathbf{A} \mathbf{b} \), with OpenMP and MPI parallelization, where \( \mathbf{b} \) is a diagonal matrix.  <br /></td></tr>
<tr class="separator:ae1c8f872ee43f871dd43e98a88d66cb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4b899b1ef4b3826cf68cb6f837aa9cf"><td class="memTemplParams" colspan="2">template&lt;typename T , typename ForwardIt , typename std::enable_if&lt; std::is_convertible&lt; typename std::iterator_traits&lt; ForwardIt &gt;::value_type, T &gt;::value, bool &gt;::type  = true&gt; </td></tr>
<tr class="memitem:af4b899b1ef4b3826cf68cb6f837aa9cf"><td class="memTemplItemLeft" align="right" valign="top">Mat&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d31/namespacetanuki_1_1math_1_1linear.html#af4b899b1ef4b3826cf68cb6f837aa9cf">TrioProduct</a> (MPI_Comm mpi_comm, const Mat&lt; T &gt; &amp;a, ForwardIt b_first)</td></tr>
<tr class="memdesc:af4b899b1ef4b3826cf68cb6f837aa9cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the matrix product, \( \mathbf{A} \mathbf{b}
\mathbf{A}^{\dagger} \), with OpenMP and MPI parallelization, where \(
\mathbf{b} \) is a diagonal matrix.  <br /></td></tr>
<tr class="separator:af4b899b1ef4b3826cf68cb6f837aa9cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ee94a45ed55e7d2c291235752f566d7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6ee94a45ed55e7d2c291235752f566d7"><td class="memTemplItemLeft" align="right" valign="top">Mat&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d31/namespacetanuki_1_1math_1_1linear.html#a6ee94a45ed55e7d2c291235752f566d7">MatrixProduct</a> (MPI_Comm mpi_comm, arma::Mat&lt; T &gt; a)</td></tr>
<tr class="separator:a6ee94a45ed55e7d2c291235752f566d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09f76a2bfaabf8852424fbb565d1478a"><td class="memTemplParams" colspan="2">template&lt;typename OutputIt , typename std::enable_if&lt; std::is_floating_point&lt; typename std::iterator_traits&lt; OutputIt &gt;::value_type &gt;::value, bool &gt;::type  = true&gt; </td></tr>
<tr class="memitem:a09f76a2bfaabf8852424fbb565d1478a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d31/namespacetanuki_1_1math_1_1linear.html#a09f76a2bfaabf8852424fbb565d1478a">Convert</a> (const <a class="el" href="../../d2/d5a/structtanuki_1_1math_1_1linear_1_1NumberArray.html">NumberArray</a> &amp;src, OutputIt d_first)</td></tr>
<tr class="memdesc:a09f76a2bfaabf8852424fbb565d1478a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts <a class="el" href="../../d2/d5a/structtanuki_1_1math_1_1linear_1_1NumberArray.html">NumberArray</a> to a range of real numbers.  <br /></td></tr>
<tr class="separator:a09f76a2bfaabf8852424fbb565d1478a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac65ea1cda48fd6efe86e7bf3e6098c58"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac65ea1cda48fd6efe86e7bf3e6098c58"><td class="memTemplItemLeft" align="right" valign="top">Mat&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d31/namespacetanuki_1_1math_1_1linear.html#ac65ea1cda48fd6efe86e7bf3e6098c58">CreateOperatorBraKetMatrix</a> (MPI_Comm mpi_comm, const Mat&lt; T &gt; &amp;op_mat_rep, const Mat&lt; T &gt; &amp;basis, bool is_hermitian)</td></tr>
<tr class="memdesc:ac65ea1cda48fd6efe86e7bf3e6098c58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an operator in bra-ket matrix using the matrix representation of the operator in the specified basis functions.  <br /></td></tr>
<tr class="separator:ac65ea1cda48fd6efe86e7bf3e6098c58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4858717433e81386231d526d87343abf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="../../dd/d13/structtanuki_1_1math_1_1linear_1_1RotationMatrixSpec.html">RotationMatrixSpec</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d31/namespacetanuki_1_1math_1_1linear.html#a4858717433e81386231d526d87343abf">CreateIdentityRotation</a> ()</td></tr>
<tr class="memdesc:a4858717433e81386231d526d87343abf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a specification for an identity rotation matrix.  <br /></td></tr>
<tr class="separator:a4858717433e81386231d526d87343abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5d88bcc1beaed10ad321352f7e4eca2"><td class="memItemLeft" align="right" valign="top">Mat&lt; real_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d31/namespacetanuki_1_1math_1_1linear.html#ad5d88bcc1beaed10ad321352f7e4eca2">CreateGivensRotation</a> (const <a class="el" href="../../dd/d13/structtanuki_1_1math_1_1linear_1_1RotationMatrixSpec.html">RotationMatrixSpec</a> &amp;spec, size_t size, size_t row1, size_t row2)</td></tr>
<tr class="memdesc:ad5d88bcc1beaed10ad321352f7e4eca2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a Givens rotation matrix from a specification.  <br /></td></tr>
<tr class="separator:ad5d88bcc1beaed10ad321352f7e4eca2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d43efa291965279ff718443d7568fae"><td class="memItemLeft" align="right" valign="top">SpMat&lt; real_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d31/namespacetanuki_1_1math_1_1linear.html#a7d43efa291965279ff718443d7568fae">CreateGivensRotationSp</a> (const <a class="el" href="../../dd/d13/structtanuki_1_1math_1_1linear_1_1RotationMatrixSpec.html">RotationMatrixSpec</a> &amp;spec, size_t size, size_t row1, size_t row2)</td></tr>
<tr class="memdesc:a7d43efa291965279ff718443d7568fae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <a class="el" href="../../d3/d31/namespacetanuki_1_1math_1_1linear.html#ad5d88bcc1beaed10ad321352f7e4eca2">CreateGivensRotation</a> but as a sparse matrix.  <br /></td></tr>
<tr class="separator:a7d43efa291965279ff718443d7568fae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac243152fca3ef58907924ee6335aa4ab"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac243152fca3ef58907924ee6335aa4ab"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d31/namespacetanuki_1_1math_1_1linear.html#ac243152fca3ef58907924ee6335aa4ab">SetGivensRotation</a> (const <a class="el" href="../../dd/d13/structtanuki_1_1math_1_1linear_1_1RotationMatrixSpec.html">RotationMatrixSpec</a> &amp;spec, size_t row1, size_t row2, arma::Mat&lt; T &gt; &amp;matrix)</td></tr>
<tr class="memdesc:ac243152fca3ef58907924ee6335aa4ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the four elements of a Givens rotation matrix from a specification.  <br /></td></tr>
<tr class="separator:ac243152fca3ef58907924ee6335aa4ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a953dba0d10d8e03462e910227350d294"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a953dba0d10d8e03462e910227350d294"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d31/namespacetanuki_1_1math_1_1linear.html#a953dba0d10d8e03462e910227350d294">SetGivensRotation</a> (const <a class="el" href="../../dd/d13/structtanuki_1_1math_1_1linear_1_1RotationMatrixSpec.html">RotationMatrixSpec</a> &amp;spec, size_t row1, size_t row2, Mat&lt; T &gt; &amp;matrix)</td></tr>
<tr class="separator:a953dba0d10d8e03462e910227350d294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd232f587458793a75c925d8b5dd67c1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:abd232f587458793a75c925d8b5dd67c1"><td class="memTemplItemLeft" align="right" valign="top">Mat&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d31/namespacetanuki_1_1math_1_1linear.html#abd232f587458793a75c925d8b5dd67c1">ForwardSubstitute</a> (MPI_Comm mpi_comm, const Mat&lt; T &gt; &amp;lower_coeffs, const Mat&lt; T &gt; &amp;constants)</td></tr>
<tr class="memdesc:abd232f587458793a75c925d8b5dd67c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves a system of linear equations, \( \mathbf{L} \mathbf{x} =
\mathbf{b} \), using forward substitution.  <br /></td></tr>
<tr class="separator:abd232f587458793a75c925d8b5dd67c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a551c1a4c3fa3339c8b5d1e4de1c2fb2d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a551c1a4c3fa3339c8b5d1e4de1c2fb2d"><td class="memTemplItemLeft" align="right" valign="top">Mat&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d31/namespacetanuki_1_1math_1_1linear.html#a551c1a4c3fa3339c8b5d1e4de1c2fb2d">BackSubstitute</a> (MPI_Comm mpi_comm, const Mat&lt; T &gt; &amp;upper_coeffs, const Mat&lt; T &gt; &amp;constants)</td></tr>
<tr class="memdesc:a551c1a4c3fa3339c8b5d1e4de1c2fb2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves a system of linear equations, \( \mathbf{U} \mathbf{x} =
\mathbf{b} \), using back substitution.  <br /></td></tr>
<tr class="separator:a551c1a4c3fa3339c8b5d1e4de1c2fb2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e6a0b24a4d2a14887e92850410b9dc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a92e6a0b24a4d2a14887e92850410b9dc"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d0/d4d/structtanuki_1_1parallel_1_1grs_1_1Result.html">parallel::grs::Result</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d31/namespacetanuki_1_1math_1_1linear.html#a92e6a0b24a4d2a14887e92850410b9dc">WeightOrthogonalized</a> (const Mat&lt; T &gt; &amp;nonortho_matrix, const Mat&lt; T &gt; &amp;prelim_ortho_matrix, const vector&lt; real_t &gt; &amp;weights, real_t zero_abs_thresh, <a class="el" href="../../df/d4f/classtanuki_1_1parallel_1_1grs_1_1Actuator.html">Actuator</a>&lt; T &gt; &amp;actuator)</td></tr>
<tr class="memdesc:a92e6a0b24a4d2a14887e92850410b9dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Orthogonalization with weights.  <br /></td></tr>
<tr class="separator:a92e6a0b24a4d2a14887e92850410b9dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfadd3efc47d9aea6a87aa309138e5e7"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:acfadd3efc47d9aea6a87aa309138e5e7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="../../d0/d4d/structtanuki_1_1parallel_1_1grs_1_1Result.html">parallel::grs::Result</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d31/namespacetanuki_1_1math_1_1linear.html#acfadd3efc47d9aea6a87aa309138e5e7">WeightOrthogonalized</a> (MPI_Comm mpi_comm, const Mat&lt; T &gt; &amp;nonortho_matrix, const Mat&lt; T &gt; &amp;prelim_ortho_matrix, const vector&lt; real_t &gt; &amp;weights, size_t max_sweeps=100, real_t zero_abs_thresh=1.0e-5)</td></tr>
<tr class="memdesc:acfadd3efc47d9aea6a87aa309138e5e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Orthogonalization with weights using a default parallelization strategy.  <br /></td></tr>
<tr class="separator:acfadd3efc47d9aea6a87aa309138e5e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96716607fcb9f3fb7fd146840b71667e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d31/namespacetanuki_1_1math_1_1linear.html#a96716607fcb9f3fb7fd146840b71667e">TEST</a> (<a class="el" href="../../d3/d31/namespacetanuki_1_1math_1_1linear.html#a2bf93f4252e39d78e6d62435f773fdc4">EquationSystemSolution</a>, RealCoefficients)</td></tr>
<tr class="memdesc:a96716607fcb9f3fb7fd146840b71667e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests solving a system of linear equations that has real coefficients.  <br /></td></tr>
<tr class="separator:a96716607fcb9f3fb7fd146840b71667e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05cff911e237ed65c4141f6de3dfa73c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a05cff911e237ed65c4141f6de3dfa73c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d31/namespacetanuki_1_1math_1_1linear.html#a05cff911e237ed65c4141f6de3dfa73c">TEST_IteratedGramSchmidt_Qr</a> (size_t num_rows, size_t num_cols)</td></tr>
<tr class="memdesc:a05cff911e237ed65c4141f6de3dfa73c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests iterated Gram-Schmidt process as a method of QR decomposition.  <br /></td></tr>
<tr class="separator:a05cff911e237ed65c4141f6de3dfa73c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6005691d692aede53bc8bc9d07eaa1ae"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d31/namespacetanuki_1_1math_1_1linear.html#a6005691d692aede53bc8bc9d07eaa1ae">TEST</a> (<a class="el" href="../../d3/d31/namespacetanuki_1_1math_1_1linear.html#ac0b643b871d049345e0c2c204b5f56ca">IteratedGramSchmidt</a>, Qr)</td></tr>
<tr class="memdesc:a6005691d692aede53bc8bc9d07eaa1ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests iterated Gram-Schmidt process as a method of QR decomposition.  <br /></td></tr>
<tr class="separator:a6005691d692aede53bc8bc9d07eaa1ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0cd663ba433d13a3799205d8e96db4f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae0cd663ba433d13a3799205d8e96db4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d31/namespacetanuki_1_1math_1_1linear.html#ae0cd663ba433d13a3799205d8e96db4f">TEST_MatrixProduct_Calculate</a> (size_t mat_size)</td></tr>
<tr class="memdesc:ae0cd663ba433d13a3799205d8e96db4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests calculating a matrix product.  <br /></td></tr>
<tr class="separator:ae0cd663ba433d13a3799205d8e96db4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fda7b29b36bc91e1114bb8d3ed7f320"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d31/namespacetanuki_1_1math_1_1linear.html#a7fda7b29b36bc91e1114bb8d3ed7f320">TEST</a> (<a class="el" href="../../d3/d31/namespacetanuki_1_1math_1_1linear.html#a88d71c61fce62c7deffa851d4bb540b5">MatrixProduct</a>, Calculate)</td></tr>
<tr class="memdesc:a7fda7b29b36bc91e1114bb8d3ed7f320"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests calculating a matrix product.  <br /></td></tr>
<tr class="separator:a7fda7b29b36bc91e1114bb8d3ed7f320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1434f643f8228aaf6e0df65cc9875cfc"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1434f643f8228aaf6e0df65cc9875cfc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d31/namespacetanuki_1_1math_1_1linear.html#a1434f643f8228aaf6e0df65cc9875cfc">TEST_DuoProduct_WeightedOrbs</a> (size_t num_orbs)</td></tr>
<tr class="memdesc:a1434f643f8228aaf6e0df65cc9875cfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests creating a ket matrix of orbitals multiplied by a real diagonal matrix of weights using <a class="el" href="../../d3/d31/namespacetanuki_1_1math_1_1linear.html#ae1c8f872ee43f871dd43e98a88d66cb4">DuoProduct</a>.  <br /></td></tr>
<tr class="separator:a1434f643f8228aaf6e0df65cc9875cfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec0f38799db5e4fbf6cb706301c70b2d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d31/namespacetanuki_1_1math_1_1linear.html#aec0f38799db5e4fbf6cb706301c70b2d">TEST</a> (<a class="el" href="../../d3/d31/namespacetanuki_1_1math_1_1linear.html#ae1c8f872ee43f871dd43e98a88d66cb4">DuoProduct</a>, WeightedOrbs)</td></tr>
<tr class="memdesc:aec0f38799db5e4fbf6cb706301c70b2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests creating a ket matrix of orbitals multiplied by a real diagonal matrix of weights using <a class="el" href="../../d3/d31/namespacetanuki_1_1math_1_1linear.html#ae1c8f872ee43f871dd43e98a88d66cb4">DuoProduct</a>.  <br /></td></tr>
<tr class="separator:aec0f38799db5e4fbf6cb706301c70b2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a751af7fefbb5425fc32626db03a11718"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a751af7fefbb5425fc32626db03a11718"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d31/namespacetanuki_1_1math_1_1linear.html#a751af7fefbb5425fc32626db03a11718">TEST_TrioProduct_DensityOperator</a> (size_t num_orbs)</td></tr>
<tr class="memdesc:a751af7fefbb5425fc32626db03a11718"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests creating a first-order density operator in bra-ket matrix using <a class="el" href="../../d3/d31/namespacetanuki_1_1math_1_1linear.html#af4b899b1ef4b3826cf68cb6f837aa9cf">TrioProduct</a>.  <br /></td></tr>
<tr class="separator:a751af7fefbb5425fc32626db03a11718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a842bb272ade7e9440800469ad82165cc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d31/namespacetanuki_1_1math_1_1linear.html#a842bb272ade7e9440800469ad82165cc">TEST</a> (<a class="el" href="../../d3/d31/namespacetanuki_1_1math_1_1linear.html#af4b899b1ef4b3826cf68cb6f837aa9cf">TrioProduct</a>, DensityOperator)</td></tr>
<tr class="memdesc:a842bb272ade7e9440800469ad82165cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests creating a first-order density operator in bra-ket matrix using <a class="el" href="../../d3/d31/namespacetanuki_1_1math_1_1linear.html#af4b899b1ef4b3826cf68cb6f837aa9cf">TrioProduct</a>.  <br /></td></tr>
<tr class="separator:a842bb272ade7e9440800469ad82165cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba70ade8182c979d3860916c0b25ddf8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d31/namespacetanuki_1_1math_1_1linear.html#aba70ade8182c979d3860916c0b25ddf8">TEST</a> (<a class="el" href="../../d2/d5a/structtanuki_1_1math_1_1linear_1_1NumberArray.html">NumberArray</a>, ArmadilloConversion)</td></tr>
<tr class="memdesc:aba70ade8182c979d3860916c0b25ddf8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests conversions between <a class="el" href="../../d2/d5a/structtanuki_1_1math_1_1linear_1_1NumberArray.html">NumberArray</a> and an Armadillo container.  <br /></td></tr>
<tr class="separator:aba70ade8182c979d3860916c0b25ddf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a550873c0f2e5c7c6de922ce8f8cfd780"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a550873c0f2e5c7c6de922ce8f8cfd780"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d31/namespacetanuki_1_1math_1_1linear.html#a550873c0f2e5c7c6de922ce8f8cfd780">TEST_NumberArray_Avro</a> ()</td></tr>
<tr class="memdesc:a550873c0f2e5c7c6de922ce8f8cfd780"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests Avro serialization of <a class="el" href="../../d2/d5a/structtanuki_1_1math_1_1linear_1_1NumberArray.html">NumberArray</a>.  <br /></td></tr>
<tr class="separator:a550873c0f2e5c7c6de922ce8f8cfd780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af665a8475705e5767870dabf57dda9e7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d31/namespacetanuki_1_1math_1_1linear.html#af665a8475705e5767870dabf57dda9e7">TEST</a> (NumberArrayTestSuite, Avro)</td></tr>
<tr class="memdesc:af665a8475705e5767870dabf57dda9e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests Avro serialization of <a class="el" href="../../d2/d5a/structtanuki_1_1math_1_1linear_1_1NumberArray.html">NumberArray</a>.  <br /></td></tr>
<tr class="separator:af665a8475705e5767870dabf57dda9e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86abe7948ab53bc4c74375cbed7e0746"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a86abe7948ab53bc4c74375cbed7e0746"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="../../d3/d31/namespacetanuki_1_1math_1_1linear.html#a86abe7948ab53bc4c74375cbed7e0746">TEST_OperatorRepresentation_BraKet</a> (size_t mat_size)</td></tr>
<tr class="memdesc:a86abe7948ab53bc4c74375cbed7e0746"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests creating a non-Hermitian operator in bra-ket matrix.  <br /></td></tr>
<tr class="separator:a86abe7948ab53bc4c74375cbed7e0746"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07c17747154680f1792032e0b77add17"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/d31/namespacetanuki_1_1math_1_1linear.html#a07c17747154680f1792032e0b77add17">TEST</a> (OperatorRepresentation, BraKet)</td></tr>
<tr class="memdesc:a07c17747154680f1792032e0b77add17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests creating a non-Hermitian operator in bra-ket matrix.  <br /></td></tr>
<tr class="separator:a07c17747154680f1792032e0b77add17"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ac20acd153246fd5892b4d2f7da77023d" name="ac20acd153246fd5892b4d2f7da77023d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac20acd153246fd5892b4d2f7da77023d">&#9670;&#160;</a></span>EigSolver</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="../../d3/d31/namespacetanuki_1_1math_1_1linear.html#ac20acd153246fd5892b4d2f7da77023d">tanuki::math::linear::EigSolver</a> = typedef function&lt; void(Col&lt;real_t&gt; &amp;, Mat&lt;T&gt; &amp;, const Mat&lt;T&gt; &amp;, const Mat&lt;T&gt; &amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of function that solves a generalized eigenvalue equation. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of numbers in eigenvectors.</td></tr>
  </table>
  </dd>
</dl>
<p>Generalized eigenvalue equation takes on the form, \( \mathbf{A}
\mathbf{X} = \mathbf{B} \mathbf{X} \mathbf{D} \), where \( \mathbf{D} \) is the diagonal matrix of real eigenvalues, \( \mathbf{X} \) is the square matrix with eigenvectors as columns, \( \mathbf{A} \) is Hermitian, and \( \mathbf{B} \) is Hermitian and positive definite. The arguments of the function are</p><ol type="1">
<li>[out] eigenvalues as a real column vector whose elements are the diagonal elements of \( \mathbf{D} \),</li>
<li>[out] eigenvectors as columns in \( \mathbf{X} \),</li>
<li>[in] \( \mathbf{A} \), and</li>
<li>[in] \( \mathbf{B} \). </li>
</ol>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a551c1a4c3fa3339c8b5d1e4de1c2fb2d" name="a551c1a4c3fa3339c8b5d1e4de1c2fb2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a551c1a4c3fa3339c8b5d1e4de1c2fb2d">&#9670;&#160;</a></span>BackSubstitute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Mat&lt; T &gt; tanuki::math::linear::BackSubstitute </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>mpi_comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>upper_coeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>constants</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves a system of linear equations, \( \mathbf{U} \mathbf{x} =
\mathbf{b} \), using back substitution. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of matrix elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mpi_comm</td><td>MPI communicator.</td></tr>
    <tr><td class="paramname">upper_coeffs</td><td>Upper triangular matrix of coefficients, \( \mathbf{U} \). It must be a square matrix. Elements below the diagonal are assumed to be zero. If they are not, the computed solution will be invalid.</td></tr>
    <tr><td class="paramname">constants</td><td>Constants, \( \mathbf{b} \), containing one or many columns. Number of rows must be the same as the number of rows/columns in <code>upper_coeffs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Solution, \( \mathbf{x} \). </dd></dl>

</div>
</div>
<a id="a09f76a2bfaabf8852424fbb565d1478a" name="a09f76a2bfaabf8852424fbb565d1478a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09f76a2bfaabf8852424fbb565d1478a">&#9670;&#160;</a></span>Convert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename OutputIt , typename std::enable_if&lt; std::is_floating_point&lt; typename std::iterator_traits&lt; OutputIt &gt;::value_type &gt;::value, bool &gt;::type  = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tanuki::math::linear::Convert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d2/d5a/structtanuki_1_1math_1_1linear_1_1NumberArray.html">NumberArray</a> &amp;&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutputIt&#160;</td>
          <td class="paramname"><em>d_first</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts <a class="el" href="../../d2/d5a/structtanuki_1_1math_1_1linear_1_1NumberArray.html">NumberArray</a> to a range of real numbers. </p>
<p>Converts <a class="el" href="../../d2/d5a/structtanuki_1_1math_1_1linear_1_1NumberArray.html">NumberArray</a> to a range of complex numbers.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputIt</td><td>Must meet the requirements of <code>LegacyOutputIterator</code> and have a dereferenced type that is floating-point.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Source <a class="el" href="../../d2/d5a/structtanuki_1_1math_1_1linear_1_1NumberArray.html">NumberArray</a>.</td></tr>
    <tr><td class="paramname">d_first</td><td>Beginning of the destination range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::range_error</td><td><code>this</code> is complex.</td></tr>
    <tr><td class="paramname">std::length_error</td><td>Size of <a class="el" href="../../">real</a> is not equal to <a class="el" href="../../">num_elems</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">OutputIt</td><td>Must meet the requirements of <code>LegacyOutputIterator</code> and have a dereferenced type that is <a class="el" href="../../">complex_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>Source <a class="el" href="../../d2/d5a/structtanuki_1_1math_1_1linear_1_1NumberArray.html">NumberArray</a>.</td></tr>
    <tr><td class="paramname">d_first</td><td>Beginning of the destination range.</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::length_error</td><td>Size of <a class="el" href="../../">real</a> or <a class="el" href="../../">imag</a> is not equal to <a class="el" href="../../">num_elems</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad5d88bcc1beaed10ad321352f7e4eca2" name="ad5d88bcc1beaed10ad321352f7e4eca2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5d88bcc1beaed10ad321352f7e4eca2">&#9670;&#160;</a></span>CreateGivensRotation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arma::Mat&lt; real_t &gt; tanuki::math::linear::CreateGivensRotation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dd/d13/structtanuki_1_1math_1_1linear_1_1RotationMatrixSpec.html">RotationMatrixSpec</a> &amp;&#160;</td>
          <td class="paramname"><em>spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>row1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>row2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a Givens rotation matrix from a specification. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spec</td><td>Specification of the rotation matrix.</td></tr>
    <tr><td class="paramname">size</td><td>Size of the Givens rotation matrix. If it is not at least <code>2</code>, <code>std::length_error</code> is thrown.</td></tr>
    <tr><td class="paramname">row1</td><td>Index of one of the rows to rotate. If it is greater than or equal to <code>size</code>, <code>std::domain_error</code> is thrown.</td></tr>
    <tr><td class="paramname">row2</td><td>Index of the other row to rotate. If it is greater than or equal to <code>size</code>, <code>std::domain_error</code> is thrown. If it is the same as <code>row1</code>, <code>std::invalid_argument</code> is thrown.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>size</code>-by-<code>size</code> Givens rotation matrix. </dd></dl>

</div>
</div>
<a id="a7d43efa291965279ff718443d7568fae" name="a7d43efa291965279ff718443d7568fae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d43efa291965279ff718443d7568fae">&#9670;&#160;</a></span>CreateGivensRotationSp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">arma::SpMat&lt; real_t &gt; tanuki::math::linear::CreateGivensRotationSp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dd/d13/structtanuki_1_1math_1_1linear_1_1RotationMatrixSpec.html">RotationMatrixSpec</a> &amp;&#160;</td>
          <td class="paramname"><em>spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>row1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>row2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <a class="el" href="../../d3/d31/namespacetanuki_1_1math_1_1linear.html#ad5d88bcc1beaed10ad321352f7e4eca2">CreateGivensRotation</a> but as a sparse matrix. </p>

</div>
</div>
<a id="a4858717433e81386231d526d87343abf" name="a4858717433e81386231d526d87343abf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4858717433e81386231d526d87343abf">&#9670;&#160;</a></span>CreateIdentityRotation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../dd/d13/structtanuki_1_1math_1_1linear_1_1RotationMatrixSpec.html">RotationMatrixSpec</a> tanuki::math::linear::CreateIdentityRotation </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a specification for an identity rotation matrix. </p>

</div>
</div>
<a id="ac65ea1cda48fd6efe86e7bf3e6098c58" name="ac65ea1cda48fd6efe86e7bf3e6098c58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac65ea1cda48fd6efe86e7bf3e6098c58">&#9670;&#160;</a></span>CreateOperatorBraKetMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Mat&lt; T &gt; tanuki::math::linear::CreateOperatorBraKetMatrix </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>mpi_comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>op_mat_rep</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_hermitian</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an operator in bra-ket matrix using the matrix representation of the operator in the specified basis functions. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of elements in an Armadillo matrix. It must be <a class="el" href="../../">tanuki::number::real_t</a> or <a class="el" href="../../">tanuki::number::complex_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mpi_comm</td><td>MPI communicator.</td></tr>
    <tr><td class="paramname">op_mat_rep</td><td>Matrix representation of the operator in <code>basis</code>.</td></tr>
    <tr><td class="paramname">basis</td><td>Basis functions as a ket matrix. It is the upper triangular matrix from the Cholesky decomposition of the basis overlap matrix.</td></tr>
    <tr><td class="paramname">is_hermitian</td><td>Whether the operator is Hermitian. If <code>false</code>, an additional conjugate transposition is performed so that the valid form of the operator can be returned. Such additional conjugate transposition is unnecessary for a Hermitian operator.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Operator in bra-ket matrix. It is \( \hat{\mathcal{O}} \) in \(
  \boldsymbol{\Phi}^{\dagger} \hat{\mathcal{O}} \boldsymbol{\Phi} =
  \mathbf{O} \), where \( \boldsymbol{\Phi} \) is <code>basis</code>, and \( \mathbf{O} \) is <code>op_mat_rep</code>. </dd></dl>

</div>
</div>
<a id="ae1c8f872ee43f871dd43e98a88d66cb4" name="ae1c8f872ee43f871dd43e98a88d66cb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1c8f872ee43f871dd43e98a88d66cb4">&#9670;&#160;</a></span>DuoProduct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ForwardIt , typename std::enable_if&lt; std::is_convertible&lt; typename std::iterator_traits&lt; ForwardIt &gt;::value_type, T &gt;::value, bool &gt;::type  = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Mat&lt; T &gt; tanuki::math::linear::DuoProduct </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>mpi_comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>b_first</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates the matrix product, \( \mathbf{A} \mathbf{b} \), with OpenMP and MPI parallelization, where \( \mathbf{b} \) is a diagonal matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of elements in an Armadillo matrix. It must be <a class="el" href="../../">tanuki::number::real_t</a> or <a class="el" href="../../">tanuki::number::complex_t</a>.</td></tr>
    <tr><td class="paramname">ForwardIt</td><td>Must meet the requirements of <code>LegacyForwardIterator</code> and have a dereferenced type that is convertible to <code>T</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mpi_comm</td><td>MPI communicator.</td></tr>
    <tr><td class="paramname">a</td><td>\( \mathbf{A} \).</td></tr>
    <tr><td class="paramname">b_first</td><td>Beginning of the range of elements that are along the diagonal of \(
  \mathbf{b} \). Behavior is undefined if the range has fewer elements than there are columns in \( \mathbf{A} \).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>\( \mathbf{A} \mathbf{b} \). </dd></dl>

</div>
</div>
<a id="a2bf93f4252e39d78e6d62435f773fdc4" name="a2bf93f4252e39d78e6d62435f773fdc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bf93f4252e39d78e6d62435f773fdc4">&#9670;&#160;</a></span>EquationSystemSolution()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Mat&lt; T &gt; tanuki::math::linear::EquationSystemSolution </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>mpi_comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>coeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>constants</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves a system of linear equations, \( \mathbf{A} \mathbf{x} =
\mathbf{b} \). </p>
<p>Current implementation employs QR decomposition using <a class="el" href="../../d3/d31/namespacetanuki_1_1math_1_1linear.html#ac0b643b871d049345e0c2c204b5f56ca">IteratedGramSchmidt</a> with default values.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of matrix elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mpi_comm</td><td>MPI communicator.</td></tr>
    <tr><td class="paramname">coeffs</td><td>Matrix of coefficients, \( \mathbf{A} \). It must be a square matrix.</td></tr>
    <tr><td class="paramname">constants</td><td>Constants, \( \mathbf{b} \), containing one or many columns. Number of rows must be the same as the number of rows/columns in <code>coeffs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Solution, \( \mathbf{x} \). </dd></dl>

</div>
</div>
<a id="abd232f587458793a75c925d8b5dd67c1" name="abd232f587458793a75c925d8b5dd67c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd232f587458793a75c925d8b5dd67c1">&#9670;&#160;</a></span>ForwardSubstitute()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Mat&lt; T &gt; tanuki::math::linear::ForwardSubstitute </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>mpi_comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>lower_coeffs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>constants</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves a system of linear equations, \( \mathbf{L} \mathbf{x} =
\mathbf{b} \), using forward substitution. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of matrix elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mpi_comm</td><td>MPI communicator.</td></tr>
    <tr><td class="paramname">lower_coeffs</td><td>Lower triangular matrix of coefficients, \( \mathbf{L} \). It must be a square matrix. Elements above the diagonal are assumed to be zero. If they are not, the computed solution will be invalid.</td></tr>
    <tr><td class="paramname">constants</td><td>Constants, \( \mathbf{b} \), containing one or many columns. Number of rows must be the same as the number of rows/columns in <code>lower_coeffs</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Solution, \( \mathbf{x} \). </dd></dl>

</div>
</div>
<a id="ac0b643b871d049345e0c2c204b5f56ca" name="ac0b643b871d049345e0c2c204b5f56ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0b643b871d049345e0c2c204b5f56ca">&#9670;&#160;</a></span>IteratedGramSchmidt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/dab/structtanuki_1_1math_1_1linear_1_1QrDecomposition.html">QrDecomposition</a>&lt; T &gt; tanuki::math::linear::IteratedGramSchmidt </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>mpi_comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const arma::Mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real_t&#160;</td>
          <td class="paramname"><em>reortho_thresh_factor</em> = <code>0.5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_reorthos</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real_t&#160;</td>
          <td class="paramname"><em>zero_norm_abs_thresh</em> = <code>1.0e-5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Numerically stable Gram-Schmidt process with reorthogonalization. </p>
<p>The variant implemented is iterated classical Gram-Schmidt process (Bjorck 1994).</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of elements in an Armadillo matrix. It must be <a class="el" href="../../">tanuki::number::real_t</a> or <a class="el" href="../../">tanuki::number::complex_t</a>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mpi_comm</td><td>MPI communicator.</td></tr>
    <tr><td class="paramname">matrix</td><td>Matrix to decompose. Number of rows must be at least the number of columns.</td></tr>
    <tr><td class="paramname">reortho_thresh_factor</td><td>A fixed value in the range \( \left( 1.2 \epsilon, 0.83 - \epsilon
  \right) \) for determining whether to reorthogonalize a column. If \(
  \left| \hat{q}^{(p + 1)} \right| &lt; \alpha \left| \hat{q}^{p} \right| \) for the \( p \)-th orthogonalization, \( \hat{q}^{(p + 1)} \) is reorthogonalized. Reorthogonalization of \( \hat{q} \) continues until the threshold is satisfied or <code>max_reorthos</code> is encountered, whichever comes first. A recommended value is <code>0.5</code> for accurate orthogonality.</td></tr>
    <tr><td class="paramname">max_reorthos</td><td>Maximum number of reorthogonalizations of a column. One reorthogonalization is usually sufficient. However, if the matrix is numerically rank-deficient, more reorthogonalizations would be needed. If <code>0</code>, orthogonality is potentially lost due to numerical errors.</td></tr>
    <tr><td class="paramname">zero_norm_abs_thresh</td><td>Absolute threshold for determining whether a vector is zero by its norm. It must be positive.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>QR decomposition of <code>matrix</code>. </dd></dl>

</div>
</div>
<a id="a0050bbd470dbe20f831a88dad4f8a5a1" name="a0050bbd470dbe20f831a88dad4f8a5a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0050bbd470dbe20f831a88dad4f8a5a1">&#9670;&#160;</a></span>IteratedGramSchmidt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d6/dab/structtanuki_1_1math_1_1linear_1_1QrDecomposition.html">QrDecomposition</a>&lt; T &gt; tanuki::math::linear::IteratedGramSchmidt </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>mpi_comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real_t&#160;</td>
          <td class="paramname"><em>reortho_thresh_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_reorthos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real_t&#160;</td>
          <td class="paramname"><em>zero_norm_abs_thresh</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6ee94a45ed55e7d2c291235752f566d7" name="a6ee94a45ed55e7d2c291235752f566d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ee94a45ed55e7d2c291235752f566d7">&#9670;&#160;</a></span>MatrixProduct() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Mat&lt; T &gt; tanuki::math::linear::MatrixProduct </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>mpi_comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::Mat&lt; T &gt;&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a88d71c61fce62c7deffa851d4bb540b5" name="a88d71c61fce62c7deffa851d4bb540b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88d71c61fce62c7deffa851d4bb540b5">&#9670;&#160;</a></span>MatrixProduct() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Tmats&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Mat&lt; T &gt; tanuki::math::linear::MatrixProduct </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>mpi_comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Tmats...&#160;</td>
          <td class="paramname"><em>mats</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Multiplication of Armadillo matrices with parallelization across MPI processes. </p>
<p>It cannot be invoked in an OpenMP parallel region.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of elements in Armadillo matrices. It must be supported by <code>arma::Mat</code> and <a class="el" href="../../d9/d74/namespacetanuki_1_1parallel_1_1mpi.html#a9662d993138586be9af5bd77140645ac">tanuki::parallel::mpi::MpiBasicDatatype</a>.</td></tr>
    <tr><td class="paramname">Tmats</td><td>Types where each is <code>arma::Mat&lt;T&gt;</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mpi_comm</td><td>MPI communicator.</td></tr>
    <tr><td class="paramname">a</td><td>First matrix.</td></tr>
    <tr><td class="paramname">b</td><td>Second matrix.</td></tr>
    <tr><td class="paramname">mats</td><td>Remaining matrices.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Product of <code>a</code>, <code>b</code>, and <code>mats</code> in order. </dd></dl>

</div>
</div>
<a id="ac243152fca3ef58907924ee6335aa4ab" name="ac243152fca3ef58907924ee6335aa4ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac243152fca3ef58907924ee6335aa4ab">&#9670;&#160;</a></span>SetGivensRotation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tanuki::math::linear::SetGivensRotation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dd/d13/structtanuki_1_1math_1_1linear_1_1RotationMatrixSpec.html">RotationMatrixSpec</a> &amp;&#160;</td>
          <td class="paramname"><em>spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>row1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>row2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">arma::Mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the four elements of a Givens rotation matrix from a specification. </p>
<p>Starting with an identity, it is useful in successively building a cumulative Givens rotation matrix from non-conflicting rotations.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of matrix elements.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">spec</td><td>Specification of the rotation.</td></tr>
    <tr><td class="paramname">row1</td><td>Index of one of the rows to rotate. If it is greater than or equal to the number of rows/columns in <code>matrix</code>, <code>std::domain_error</code> is thrown.</td></tr>
    <tr><td class="paramname">row2</td><td>Index of the other row to rotate. If it is greater than or equal to the number of rows/columns in <code>matrix</code>, <code>std::domain_error</code> is thrown. If it is the same as <code>row1</code>, <code>std::invalid_argument</code> is thrown.</td></tr>
    <tr><td class="paramname">matrix</td><td>Output matrix. If it is not a square matrix and does not have at least two rows/columns, <code>std::length_error</code> is thrown. Only the four elements at the intersection of <code>row1</code> and <code>row2</code> are set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a953dba0d10d8e03462e910227350d294" name="a953dba0d10d8e03462e910227350d294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a953dba0d10d8e03462e910227350d294">&#9670;&#160;</a></span>SetGivensRotation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tanuki::math::linear::SetGivensRotation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../dd/d13/structtanuki_1_1math_1_1linear_1_1RotationMatrixSpec.html">RotationMatrixSpec</a> &amp;&#160;</td>
          <td class="paramname"><em>spec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>row1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>row2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aec0f38799db5e4fbf6cb706301c70b2d" name="aec0f38799db5e4fbf6cb706301c70b2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec0f38799db5e4fbf6cb706301c70b2d">&#9670;&#160;</a></span>TEST() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tanuki::math::linear::TEST </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d31/namespacetanuki_1_1math_1_1linear.html#ae1c8f872ee43f871dd43e98a88d66cb4">DuoProduct</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">WeightedOrbs&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests creating a ket matrix of orbitals multiplied by a real diagonal matrix of weights using <a class="el" href="../../d3/d31/namespacetanuki_1_1math_1_1linear.html#ae1c8f872ee43f871dd43e98a88d66cb4">DuoProduct</a>. </p>

</div>
</div>
<a id="a96716607fcb9f3fb7fd146840b71667e" name="a96716607fcb9f3fb7fd146840b71667e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96716607fcb9f3fb7fd146840b71667e">&#9670;&#160;</a></span>TEST() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tanuki::math::linear::TEST </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d31/namespacetanuki_1_1math_1_1linear.html#a2bf93f4252e39d78e6d62435f773fdc4">EquationSystemSolution</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RealCoefficients&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests solving a system of linear equations that has real coefficients. </p>

</div>
</div>
<a id="a6005691d692aede53bc8bc9d07eaa1ae" name="a6005691d692aede53bc8bc9d07eaa1ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6005691d692aede53bc8bc9d07eaa1ae">&#9670;&#160;</a></span>TEST() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tanuki::math::linear::TEST </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d31/namespacetanuki_1_1math_1_1linear.html#ac0b643b871d049345e0c2c204b5f56ca">IteratedGramSchmidt</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Qr&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests iterated Gram-Schmidt process as a method of QR decomposition. </p>

</div>
</div>
<a id="a7fda7b29b36bc91e1114bb8d3ed7f320" name="a7fda7b29b36bc91e1114bb8d3ed7f320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fda7b29b36bc91e1114bb8d3ed7f320">&#9670;&#160;</a></span>TEST() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tanuki::math::linear::TEST </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d31/namespacetanuki_1_1math_1_1linear.html#a88d71c61fce62c7deffa851d4bb540b5">MatrixProduct</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Calculate&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests calculating a matrix product. </p>

</div>
</div>
<a id="aba70ade8182c979d3860916c0b25ddf8" name="aba70ade8182c979d3860916c0b25ddf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba70ade8182c979d3860916c0b25ddf8">&#9670;&#160;</a></span>TEST() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tanuki::math::linear::TEST </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d2/d5a/structtanuki_1_1math_1_1linear_1_1NumberArray.html">NumberArray</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ArmadilloConversion&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests conversions between <a class="el" href="../../d2/d5a/structtanuki_1_1math_1_1linear_1_1NumberArray.html">NumberArray</a> and an Armadillo container. </p>

</div>
</div>
<a id="af665a8475705e5767870dabf57dda9e7" name="af665a8475705e5767870dabf57dda9e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af665a8475705e5767870dabf57dda9e7">&#9670;&#160;</a></span>TEST() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tanuki::math::linear::TEST </td>
          <td>(</td>
          <td class="paramtype">NumberArrayTestSuite&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Avro&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests Avro serialization of <a class="el" href="../../d2/d5a/structtanuki_1_1math_1_1linear_1_1NumberArray.html">NumberArray</a>. </p>

</div>
</div>
<a id="a07c17747154680f1792032e0b77add17" name="a07c17747154680f1792032e0b77add17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07c17747154680f1792032e0b77add17">&#9670;&#160;</a></span>TEST() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tanuki::math::linear::TEST </td>
          <td>(</td>
          <td class="paramtype">OperatorRepresentation&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">BraKet&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests creating a non-Hermitian operator in bra-ket matrix. </p>

</div>
</div>
<a id="a842bb272ade7e9440800469ad82165cc" name="a842bb272ade7e9440800469ad82165cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a842bb272ade7e9440800469ad82165cc">&#9670;&#160;</a></span>TEST() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tanuki::math::linear::TEST </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d3/d31/namespacetanuki_1_1math_1_1linear.html#af4b899b1ef4b3826cf68cb6f837aa9cf">TrioProduct</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DensityOperator&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests creating a first-order density operator in bra-ket matrix using <a class="el" href="../../d3/d31/namespacetanuki_1_1math_1_1linear.html#af4b899b1ef4b3826cf68cb6f837aa9cf">TrioProduct</a>. </p>

</div>
</div>
<a id="a1434f643f8228aaf6e0df65cc9875cfc" name="a1434f643f8228aaf6e0df65cc9875cfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1434f643f8228aaf6e0df65cc9875cfc">&#9670;&#160;</a></span>TEST_DuoProduct_WeightedOrbs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tanuki::math::linear::TEST_DuoProduct_WeightedOrbs </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_orbs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests creating a ket matrix of orbitals multiplied by a real diagonal matrix of weights using <a class="el" href="../../d3/d31/namespacetanuki_1_1math_1_1linear.html#ae1c8f872ee43f871dd43e98a88d66cb4">DuoProduct</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Must be <a class="el" href="../../">tanuki::number::real_t</a> or <a class="el" href="../../">tanuki::number::complex_t</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a05cff911e237ed65c4141f6de3dfa73c" name="a05cff911e237ed65c4141f6de3dfa73c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05cff911e237ed65c4141f6de3dfa73c">&#9670;&#160;</a></span>TEST_IteratedGramSchmidt_Qr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tanuki::math::linear::TEST_IteratedGramSchmidt_Qr </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_cols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests iterated Gram-Schmidt process as a method of QR decomposition. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Must be <a class="el" href="../../">tanuki::number::real_t</a> or <a class="el" href="../../">tanuki::number::complex_t</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae0cd663ba433d13a3799205d8e96db4f" name="ae0cd663ba433d13a3799205d8e96db4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0cd663ba433d13a3799205d8e96db4f">&#9670;&#160;</a></span>TEST_MatrixProduct_Calculate()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tanuki::math::linear::TEST_MatrixProduct_Calculate </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mat_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests calculating a matrix product. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Must be <a class="el" href="../../">tanuki::number::real_t</a> or <a class="el" href="../../">tanuki::number::complex_t</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a550873c0f2e5c7c6de922ce8f8cfd780" name="a550873c0f2e5c7c6de922ce8f8cfd780"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a550873c0f2e5c7c6de922ce8f8cfd780">&#9670;&#160;</a></span>TEST_NumberArray_Avro()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tanuki::math::linear::TEST_NumberArray_Avro </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests Avro serialization of <a class="el" href="../../d2/d5a/structtanuki_1_1math_1_1linear_1_1NumberArray.html">NumberArray</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Must be <a class="el" href="../../">tanuki::number::real_t</a> or <a class="el" href="../../">tanuki::number::complex_t</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a86abe7948ab53bc4c74375cbed7e0746" name="a86abe7948ab53bc4c74375cbed7e0746"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86abe7948ab53bc4c74375cbed7e0746">&#9670;&#160;</a></span>TEST_OperatorRepresentation_BraKet()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tanuki::math::linear::TEST_OperatorRepresentation_BraKet </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mat_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests creating a non-Hermitian operator in bra-ket matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Must be <a class="el" href="../../">tanuki::number::real_t</a> or <a class="el" href="../../">tanuki::number::complex_t</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a751af7fefbb5425fc32626db03a11718" name="a751af7fefbb5425fc32626db03a11718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a751af7fefbb5425fc32626db03a11718">&#9670;&#160;</a></span>TEST_TrioProduct_DensityOperator()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void tanuki::math::linear::TEST_TrioProduct_DensityOperator </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_orbs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests creating a first-order density operator in bra-ket matrix using <a class="el" href="../../d3/d31/namespacetanuki_1_1math_1_1linear.html#af4b899b1ef4b3826cf68cb6f837aa9cf">TrioProduct</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Must be <a class="el" href="../../">tanuki::number::real_t</a> or <a class="el" href="../../">tanuki::number::complex_t</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af4b899b1ef4b3826cf68cb6f837aa9cf" name="af4b899b1ef4b3826cf68cb6f837aa9cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4b899b1ef4b3826cf68cb6f837aa9cf">&#9670;&#160;</a></span>TrioProduct()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename ForwardIt , typename std::enable_if&lt; std::is_convertible&lt; typename std::iterator_traits&lt; ForwardIt &gt;::value_type, T &gt;::value, bool &gt;::type  = true&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Mat&lt; T &gt; tanuki::math::linear::TrioProduct </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>mpi_comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ForwardIt&#160;</td>
          <td class="paramname"><em>b_first</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates the matrix product, \( \mathbf{A} \mathbf{b}
\mathbf{A}^{\dagger} \), with OpenMP and MPI parallelization, where \(
\mathbf{b} \) is a diagonal matrix. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of elements in an Armadillo matrix. It must be <a class="el" href="../../">tanuki::number::real_t</a> or <a class="el" href="../../">tanuki::number::complex_t</a>.</td></tr>
    <tr><td class="paramname">ForwardIt</td><td>Must meet the requirements of <code>LegacyForwardIterator</code> and have a dereferenced type that is convertible to <code>T</code>.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mpi_comm</td><td>MPI communicator.</td></tr>
    <tr><td class="paramname">a</td><td>\( \mathbf{A} \).</td></tr>
    <tr><td class="paramname">b_first</td><td>Beginning of the range of elements that are along the diagonal of \(
  \mathbf{b} \). Behavior is undefined if the range has fewer elements than there are columns in \( \mathbf{A} \).</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>\( \mathbf{A} \mathbf{b} \mathbf{A}^{\dagger} \). </dd></dl>

</div>
</div>
<a id="a92e6a0b24a4d2a14887e92850410b9dc" name="a92e6a0b24a4d2a14887e92850410b9dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92e6a0b24a4d2a14887e92850410b9dc">&#9670;&#160;</a></span>WeightOrthogonalized() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d4d/structtanuki_1_1parallel_1_1grs_1_1Result.html">parallel::grs::Result</a>&lt; T &gt; tanuki::math::linear::WeightOrthogonalized </td>
          <td>(</td>
          <td class="paramtype">const Mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>nonortho_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>prelim_ortho_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; real_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real_t&#160;</td>
          <td class="paramname"><em>zero_abs_thresh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/d4f/classtanuki_1_1parallel_1_1grs_1_1Actuator.html">Actuator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>actuator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Orthogonalization with weights. </p>
<p>Implementation is the weighted orthogonalization (WO) by West 2014.</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">T</td><td>Type of elements in an Armadillo matrix.</td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nonortho_matrix</td><td>Nonorthogonal matrix where the columns are normalized.</td></tr>
    <tr><td class="paramname">prelim_ortho_matrix</td><td>Orthogonal matrix whose columns are to be rotated to maximize the overlap with <code>nonortho_matrix</code>. It must have the same size as <code>nonortho_matrix</code>.</td></tr>
    <tr><td class="paramname">weights</td><td>Non-negative orthogonalization weights in corresponding order to <a class="el" href="../../">nonortho_matrix</a>. Number of elements must be the number of columns in <a class="el" href="../../">nonortho_matrix</a>.</td></tr>
    <tr><td class="paramname">zero_abs_thresh</td><td>Absolute threshold, as a positive number, for deciding whether a weight or the \( A \) coefficient is close enough to zero. It is a threshold that avoids division by a number that is too close to zero.</td></tr>
    <tr><td class="paramname">actuator</td><td>Actuator of the parallelization strategy.</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Result from GRS parallelization strategy. </dd></dl>

</div>
</div>
<a id="acfadd3efc47d9aea6a87aa309138e5e7" name="acfadd3efc47d9aea6a87aa309138e5e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfadd3efc47d9aea6a87aa309138e5e7">&#9670;&#160;</a></span>WeightOrthogonalized() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="../../d0/d4d/structtanuki_1_1parallel_1_1grs_1_1Result.html">parallel::grs::Result</a>&lt; T &gt; tanuki::math::linear::WeightOrthogonalized </td>
          <td>(</td>
          <td class="paramtype">MPI_Comm&#160;</td>
          <td class="paramname"><em>mpi_comm</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>nonortho_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Mat&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>prelim_ortho_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; real_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_sweeps</em> = <code>100</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">real_t&#160;</td>
          <td class="paramname"><em>zero_abs_thresh</em> = <code>1.0e-5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Orthogonalization with weights using a default parallelization strategy. </p>
<p>Implementation uses <a class="el" href="../../df/d4f/classtanuki_1_1parallel_1_1grs_1_1Actuator.html">parallel::grs::Actuator</a> for its default parallelization strategy.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mpi_comm</td><td>MPI communicator. The level of thread support must be at least <code>MPI_THREAD_FUNNELED</code>. Number of MPI processes at each host must be the same.</td></tr>
    <tr><td class="paramname">max_sweeps</td><td>Positive maximum number of sweeps. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="../../doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.6
</small></address>
</body>
</html>
